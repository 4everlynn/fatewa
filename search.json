[{"categories":["java"],"content":"Fatewa Spring Cli Release log Easy to build Strongerrestful API Now at version 1.0.10    Features  Service Component  Service Component 我们已经知道在Spirng Cli项目中，通过@Export注解可以快速生成Restful风格的接口，并且在 V1.0.5版本中引入了GeniusHooks来扩展我们的业务需求。\ngraph TB; r(Request\u003cT\u003e) c(Create Entity) u(Update Entity) d(Delete Entity) e(End) r --post-- hooks.beforeCreate -- c -- hooks.created -- e r --patch-- hooks.beforeUpdate -- u -- hooks.updated -- e r --delete-- hooks.beforeDelete -- d -- hooks.deleted -- e  上图为GeniusHooks周期 随着日常的使用，我们发现用户在一些场景中，使用kernel时需要对于某些类型进行格式化处理。考虑到这点，在这个版本我们增加了关于扩展插件的外部配置SpeardPlugin。\nSpreadPlugin会对请求参数进行必要的格式化后，再交由后续步骤执行。\ngraph TB; s(SpreadPlugin) r(Request\u003cT\u003e) e(End) s -- r r --post--- PostProcessing... --- e r --patch--- PatchProcessing... --- e r --get--- GetProcessing... --- e  SpreadPlugin提供了两种方式进行插件的扩展\n1 2 3 4 5 6  // 全局扩展 SpreadPlugin.spread(TypePlugin\u003c?,?\u003e plus); // 指定类型扩展 SpreadPlugin.assignSpread(Class\u003c?\u003e aClass,TypePlugin\u003c?,?\u003e plus);   在项目加载前，在你的配置中实例SpreadPlugin，如果你需要多个插件去工作，你只需要多次链式掉用spread()方法即可\n简单的使用\n1 2 3 4 5 6 7  @Bean SpreadPlugin spreadPlugin(){ return new SpreadPlugin() .spread((TypePlugin\u003cString, Integer\u003e) item -\u003e Integer.valueof(item)) .spread((TypePlugin\u003cString, Date\u003e) item -\u003e yourParseDateFoncation(item)); }   对于一些简单的类型处理，我们可能只需要一句lamda。\n当然，在这里你也可以去进行一些复杂类型的转化，比如对于时间的转化或是在使用MybatisPlus时对于通用枚举的转化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Bean SpreadPlugin spreadPlugin(){ return new SpreadPlugin() // 全局插件扩展  .spread(new TypePlugin\u003cString, Date\u003e() { @Override public Date doTrans(String s) { // 你的方法  } }) // 指定类插件扩展  .assignSpread(MyBean.class, (TypePlugin\u003cString, MyBeanEnum\u003e) s -\u003e { // 你的方法  }); }   ","description":"","tags":["Spring cli"],"title":"Fatewa | 4everlynn","uri":"/fatewa/posts/work/tags/spring-cli/1.0.10/"},{"categories":["java"],"content":"Fatewa Spring Cli Release log Easy to build Strongerrestful API Now at version 1.0.8    Features  Service Component  Service Component 随着我们的服务数量增加，寻找服务的配置文档也成为了一项复杂的工作， 考虑到这点，在这个版本中，引入了服务组件的初始化\n如上图所示，根据提示进行参数输入即可\n","description":"","tags":["Spring cli"],"title":"Fatewa | 4everlynn","uri":"/fatewa/posts/work/tags/spring-cli/1.0.8/"},{"categories":["java"],"content":"Kernel feature draft 1.0.7 设计目标  减少 PO 的功能负担 使返回层更加灵活性 Git commit 规约  ProtocolVO 针对此前 kernel 设计的 domain driven 中存在 PO 功能负担过重的问题，为 PO 合理划分职责并提供向下兼容的语法。\n流程设计 graph LR; ctl(Controller) po(PO) vo(ProtocolVO) st(Strategy) resp(Protocol Response) ctl--po-.optional.-vo--st--resp po--st  接口 1 2 3 4 5 6 7 8 9 10 11  public interface ProtocolVO\u003cT extends AncestorDomain\u003e { /** * 输入一个PO类型返回一个输出的协议类型 * * @param domain 领域模型 * @return 输出的协议类型（VO） */ ProtocolVO\u003cT\u003e translate(T domain); }   代码示例 PO 1 2 3 4 5  @Data public class User extends AncestorDomain{ private String name; private int age; }   Controller 1 2 3 4 5 6 7 8 9 10 11  @RestController @RequestMapping(\"/v1/users\") public class UserController { public User user () { return new User() .setAge(14) .setName(\"Edward Jobs\") } }   VO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @Data // 需要添加 @Component 注册入 Spring 容器 @Component public class UserVO implements ProtocolVO\u003cUser\u003e { private String n; @Override public ProtocolVO\u003cUser\u003e translate(User domain) { // new 一个 VO（注意不要返回自身）  ProtocolVO\u003cUser\u003e vo = new ProtocolVO\u003c\u003e(); // name -\u003e n  vo.setN(domain.getName()); return vo; } }   最终接口返回的 response 为(如果没有配置 VO 则还是按照原始结构返回)\n1 2 3 4 5 6 7  { code: \"E0001\", msg: \"请求成功\", data: { n: \"Edward Jobs\" } }   Git提交规范化 commit messge 规范十分有助于项目管理, 通过 msg 可以区分出提交的主题\n\u003ctype\u003e: \u003cmsg\u003e\nfeat: 新特性\nfix: 修改问题\nrefactor: 代码重构\ndocs: 文档修改\nstyle: 代码格式修改\ntest: 测试用例修改\nchore: 其他修改，比如构建流程，依赖管理\nscope: commit 影响的范围，比如: mapper、controller、service\nsubject: commit的概述\nfooter: 备注\n如果草案通过，将会通过 git hooks 的形式来约束每次提交的消息格式\n","description":"","tags":["Spring cli","draft"],"title":"Fatewa | 4everlynn","uri":"/fatewa/posts/work/kfd/"},{"categories":["javascript"],"content":"Fatewa Kinnara Release log Now at version 1.0.5     Kinnara Install Quick Start 操作指令  基础代码 Join head replace seq map observe   自定义操作命令 Kinnara 中的观察者  取消订阅 有什么用 ?    Kinnara  Kinnara 是为了解决前端应用中接口路径难管理、代码重复率高等问题而实现的基于 JSProxy 的轻量级解决方案\n Install 一般情况下，安装最新的版本即可\n1  npm i @fatewa/kinnara   Quick Start 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 定义接口路径对象 const routes = { v1: { users: '/v1/users', favorites: '/v1/favorites' } } // 实例化一个对象 const kinnara = new Kinnara() const _: any = kinnara // 设置一个 http 请求适配器  // kinnara 提供了一个 axios 的适配器  // 构造器传递的参数为 AxiosInstance  .setHttpAdapter(new AxiosHttpAdapter(axios)) // 并返回代理对象  .proxy(routes) (async () =\u003e { // 直接使用对象 key 路径对接口进行请求  const response = await _.v1.users.get() })()   直接重用路由结构，直接请求接口, 支持 自定义指令，默认提供一套操作指令, 使用 Kinnara，API路径难以管理即将成为过去。\n操作指令 我们在路径中声明的URI通常很难满足所有情况， 我们无法避免 URI 的调整 因此，Kinnara 提供了一个通用的、可扩展的命令接口，通过这些命令可以轻松地操作URL、Headers 和 其他属性。\n基础代码 下文中的命令介绍代码都有这一段通用的代码， 在此声明后下文介绍命令时不再重复编写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const kinnara = new Kinnara() // 定义接口路径对象 const routes = { v1: { users: { root: '/v1/users', single: '/v1/users/{id}' } favorites: '/v1/favorites', } // 得到代理对象 const _: any = kinnara .setHttpAdapter(new AxiosHttpAdapter(axios)) .proxy(routing)   Join 在 URL 的右边动态地添加字符串\n1 2 3 4 5 6  // 动态得到的参数值 const configId = 1 const response = _.v1.users.root .join`/${configId}` .get()   得到的 URI 为 /v1/users/1\nhead 为单次请求添加请求头\n1 2 3 4 5 6  const response = _.v1.users.root .head({ ContentType:'application/json', Origin: 'https://xxx' }) .get()   replace 替换 URI 中的占位符\n1 2 3  const response = _.v1.users.single .replace({ id: 1 }) .get()   得到的 URI 为 /v1/users/1\nseq 指令序列，可以聚合多个指令执行， 用于构建复杂的 URI 操作\n1 2 3 4 5 6 7 8  const response = _.v1.users.single .seq((chain) =\u003e { // chain provides all the instructions for the Kinnara library  chain.replace({ id: 1 }) chain.join`/issues` chain.head({ ContentType:'application/json' }) }) .get()   得到的 URI 为 /v1/users/1/issues, 并且请求时会附加 ContentType: application/json \nmap 操作原始请求对象，并进行映射，基本上可以处理任意复杂请求， 如果目前 Kinnara 所提供的命令无法满足需求，则可以使用 map\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // API参数以执行自定义操作 const resposne = _.v1.users.single .map((it: RequestWrapper) =\u003e { // 调整请求url  url: '/users', // 调整请求头  headers: {}, // 调整查询参数  query: {}, // 调整 body 参数  body: {} // 调整是否可被观察(详情见下文)  observable: true }) .get() // 或者你也可以直接将 map 中要返回的对象作为 get 的参数传入 const resposne = _.v1.users.single .get({ // 调整请求url  url: '/users', // 调整请求头  headers: {}, // 调整查询参数  query: {}, // 调整 body 参数  body: {} // 调整是否可被观察(详情见下文)  observable: true })   两种方式任选其一即可\nobserve 控制当前请求是否可被观察(见下文)\n1 2 3 4  _.v1.users.root // 设置本次请求为禁止观察  .observe(false) .get()   自定义操作命令 如果上文中所提到的命令都无法满足需求，则可以自定义命令， 我们以实现 random 命令为例， random 的作用为，在 URI 右边添加一个随机的整数\n自定义指令的本质其实是对 RequestWrapper 对象的构建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  export default class RandomCommand implements Command { /** * 当前已经处理完毕的结构 */ wrapper!: RequestWrapper /** * 命令的参数，这里我们设定一个系数 */ entrypoint (coefficient: number): RequestWrapper { return { url: `${this.wrapper.url}/${Math.random() * coefficient | 0}` } } /** * 命令在调用时的名称 */ name (): string { return 'random' } }   使用\n1 2 3 4 5  // 装载命令 Kinnara.use(RandomCommand) // 使用自定义命令 _.v1.users.root.random(100).get()   Kinnara 中的观察者 在 URL 处于请求状态时提供订阅功能，因此您可以拦截或执行一些额外的响应处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 监听一个接口的请求 // 第一个参数的类型为 RegExp ｜ string // 当路径中存在占位符时， // Kinnara 会自动将 形如 {any} 的占位符替换为 [\\w-]+? 并将字符串转为正则 kinnara.subscribe(routes.v1.users.single, (request, response) =\u003e { // ... Do anything you want  return { ...response, ext: '这是在订阅中新增的字段‘ } }) // After the listener _.v1.users.single.replace({ id: 1 }).get((response) =\u003e { // 由于订阅时新增了此字段，在调用时，可以获取到  const { ext } = response })   如果在订阅中需要再次调用被订阅的 API，为了防止栈溢出，需在订阅的处理器中 禁用观察\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  kinnara.subscribe(routes.v1.users.single, (request, response) =\u003e { _.v1.users.single.seq(chain =\u003e { chain.replace({ id: 1 }) // 标记禁用观察，避免栈溢出  chain.observe(false) }).get() return { ...response, ext: '这是在订阅中新增的字段‘ } }) _.v1.users.single.replace({ id: 1 }).get((response) =\u003e { // 由于订阅时新增了此字段，在调用时，可以获取到  const { ext } = response })   取消订阅 调用 subscribe 方法后，会得到一个 key， 取消就是通过这个 key\n1 2 3 4  const key = kinnara.subscribe(any, any) // 取消订阅 kinnara.cancel(key)   有什么用 ? 有了针对单个路径的观察模型，我们可以很容易地实现一条完整的请求链路, 并且这个链路是全局有效的\n我们假设现在拿到了一个这样的接口文档\n获取当前登录用户的角色集合 /v1/users/roles\nResponse\n1 2 3  code: 200, // 角色 ID data: [1, 2, 3, 4]   根据角色ID获取角色详情 /v1/roles/{id}\nResponse\n1 2 3 4 5 6  code: 200, // 角色 ID data: { name: '管理员', code: 'admin' }   很显然，这两个接口就是存在链路关系的, 我们使用 kinnara 对接这两个接口\n我们推荐以下的文件夹组织结构进行管理\n使用 index 进行导出, 各个模块的接口 放置在各自的文件夹中进行维护 project ├── api │ ├── user │ │ ├── index.ts │ ├── biz │ │ ├── index.ts │ └── index.ts user/index.ts\n1 2 3 4 5 6  export default { users: { root: '/users', roles: '/users/roles' } }   roles/index.ts\n1 2 3 4 5 6  export default { roles: { root: 'roles', single: '/roles/{id}' } }   index.ts\n1 2 3 4 5 6 7 8 9  import users from './users' import roles from './roles' export default { // 外层组织 API 版本号  v1: { users, roles } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import routes from '@/api' const kinnara = new Kinnara() // 得到代理对象 const _: any = kinnara .setHttpAdapter(new AxiosHttpAdapter(axios)) .proxy(routing) // 订阅请求用户角色的接口 kinnara.subscribe(routes.v1.users.roles, async (request, response) =\u003e { const { data } = response const roles = [] for (const id of data) { const role = await _.v1.roles.single.seq(chain =\u003e { chain.replace({ id }) chain.observe(false) }).get() roles.push(roles) } return { ...response, // 保留原始请求结构，复写 data 属性  data: roles } })   调用\n1 2 3 4 5  _.v1.users.roles.get() // 得到的结果 -\u003e [{ ...role（完整的 Role 对象） }]    当然这样的请求方式，显然是不够合理的，很容易导致 Qps 过高， 所以我们需要对请求的结果进行缓存（如果应用是面向 C 端的，这样的处理方式仍旧不合理）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 缓存请求到的结果 const cache = { counter: 0, data: null } // 订阅请求用户角色的接口 kinnara.subscribe(routes.v1.users.roles, async (request, response) =\u003e { const { data } = response const roles = [] if (!cache.data) { for (const id of data) { const role = await _.v1.roles.single.seq(chain =\u003e { chain.replace({ id }) chain.observe(false) }).get() roles.push(roles) } cache.data = roles } else { roles = cache.data // 缓存的数据保留 50 次，  // 次数超过 50 后，则再次请求, 一定程度保障数据的实时性  if (++cache.counter \u003e 49) { cache.data = null cache.counter = 0 } } return { ...response, // 保留原始请求结构，复写 data 属性  data: roles } })   ","description":"","tags":["lib"],"title":"Fatewa | 4everlynn","uri":"/fatewa/posts/work/tags/kinnara/1.0.5/"},{"categories":["java"],"content":"Fatewa Spring Cli Release log Easy to build Strongerrestful API Now at version 1.0.5    Features  Protocol Exception Genius Hooks Data Scopes 🔥  Protocol Exception 我们已经知道在 Spring Cli 的项目中，通过 Assert 可以返回预期的异常 Response， 但它的局限之处在于，无法调整 Http Status Code, 于是为了解决此类问题，在最新(v1.0.5) 版本中，设计了 ProtocolException, 一起来看看吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 模拟一个检查订单的方法 public void checkOrder () { // 用户未授权  if (!isAuth()) { // 返回时的 Http Status 为 401  throw new ProtocolException( ResponseCode.NO_LOGIN_ERROR, \"用户未登录\" ); } // ... 业务代码 }   ResponseCode 为枚举类型，可在 \u003cgroups\u003e.kernel.constants.ResponseCode  中进行自定义扩展 默认情况下，其结构为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  public enum ResponseCode { /** * 参数说明 */ SUCCESS(\"E0001\", \"请求成功\", HttpStatus.OK), ERROR_SERVICE(\"E1001\", \"平台服务异常\", HttpStatus.INTERNAL_SERVER_ERROR), ERROR_DB(\"E1002\", \"服务器数据库异常\", HttpStatus.INTERNAL_SERVER_ERROR), UNIQUE_KEY(\"E1003\", \"唯一值重复录入\", HttpStatus.INTERNAL_SERVER_ERROR), TRANSFORM_ERROR(\"E1004\", \"类型转换错误\", HttpStatus.INTERNAL_SERVER_ERROR), ERROR_QUERY(\"E2001\", \"请求参数异常，缺少必填项\", HttpStatus.BAD_REQUEST), ERROR_QUERY_FORMAT(\"E2002\", \"请求参数异常，参数格式不合法\", HttpStatus.BAD_REQUEST), NO_LOGIN_ERROR(\"E4001\", \"请先登录\", HttpStatus.UNAUTHORIZED); /** * 值 */ public String value; /** * 对应信息 */ public String msg; /** * 对应 Http Status */ public HttpStatus status; }   Genius Hooks 在以往的 Spring cli 版本中，我们已经能够借助于 @Export  注解所提供的能力进行 Level 2 的 Restful API 自动生成，可是在实际的业务研发中，我们发现，这些 生成的接口往往不能完全胜任业务需求或者说无法跟随业务而进行扩展，因此我们的用户还是选择自行创建 并重新实现接口，而这也就意味着，丢失了 Spring cli 中所自带的 validation scope (即区分 Create、Update 的参数校验)， 在这样的前提背景下，Genius Hooks 就自然而然的出现了。\n我们将 Genius Hooks 贯穿进了 GeniusProxyWrapper, 它的流程如下图\ngraph TB; r(Request\u003cT\u003e) c(Create Entity) u(Update Entity) d(Delete Entity) e(End) r --post-- hooks.beforeCreate -- c -- hooks.created -- e r --patch-- hooks.beforeUpdate -- u -- hooks.updated -- e r --delete-- hooks.beforeDelete -- d -- hooks.deleted -- e  使用案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  @Configuration public class KernelConfig { // 配置为 StoreInfo 的 Hook  @Bean GeniusHooks\u003cStoreInfo\u003e hooks () { return new GeniusHooks\u003cStoreInfo\u003e() { // 数据创建完成的钩子  @Override public void created(AncestorDomain domain, boolean s) { // 返回的是父类型，需要向下转型  final StoreInfo storeInfo = (StoreInfo) domain; System.out.println(storeInfo); } }; } }    在钩子内抛出异常可以中断接口进行 也可以结合上文中的 ProtocolException 进行 HttpStatus 控制\n Data Scopes 作为现代化开箱即用的应用框架，数据隔离是绕不开的话题，在此前 Spring Cli 的结构中， 由于接口的高度自动化，导致用户很难在不去调整核心源码的前提下去控制数据的隔离，但是不必担心， 在这个版本中，此机制已被实现。\n现有的核心代码中，已经集成了此功能，但默认是未开启的状态，需要向 Spring 容器中注册一个 ScopedContext 类才可以开启:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Configuration public class KernelConfig { // 配置权限上下文  @Bean public ScopedContext context(JdbcTemplate template) { return new RequestScopeContext() // Session 有效性校验器  .calibrator((authorization, request) -\u003e false) // JdbcTemplate 使用默认的即可  .jdbcTemplate(template) // 权限字段处理器  .configure(chain -\u003e chain.scope(new ScopedStore())); } }   权限字段处理器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class ScopedStore extends BaseScopeHandler\u003cList\u003cStoreInfo\u003e\u003e { // 获取时使用的 key  @Override public String key() { return \"stores\"; } // 根据需要构建SQL，从 操作符 开始写即可，  // 字段名称会进行自动注入  @Override public SqlBuilder\u003cList\u003cStoreInfo\u003e\u003e builder() { return args -\u003e Joiner.on(\"\") .join(\" in \", \"(\", Strings.join(args.stream() .map(StoreInfo::getId) .collect(Collectors.toList()), ','), \")\"); } // 使用 JdbcTemplate 进行数据库访问  @Override public List\u003cStoreInfo\u003e scopes() { final JdbcTemplate template = template(); return template.query(\"select * from biz.store_info\", BeanPropertyRowMapper.newInstance(StoreInfo.class)); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  @EqualsAndHashCode(callSuper = true) @TableName(value = \"store_info\", schema = \"biz\") @Data public class StoreInfo extends AncestorDomain { private Long pid; /** * 在对应的实体类增加注解 */ @Scoped(value = KernelConfig.ScopedStore.class, key = \"id\") @TableField(exist = false) private String storeId; }   ","description":"","tags":["Spring cli"],"title":"Fatewa | 4everlynn","uri":"/fatewa/posts/work/tags/spring-cli/1.0.5/"},{"categories":["java"],"content":"Fatewa Spring Cli Easy to build Strongerrestful API Now at version 1.0.5   Features Quick Start  Brahma Cli  选择模版 选择模版版本 输入项目描述 特性选择(Features)  特性一览表   选择数据库类型   Project  Kernel 是什么 ? Migration  状态 创建 升级 回退   MybatisX 代码生成 Controller  Response 写法  默认策略 子键策略 平铺策略 原始类型   参数合法性校验   断言 接口导出与开放字段检索  接口导出 开放字段检索   FAQ  如何使主键在请求结果中进行展示 生成的 API 格式与请求规范？ 如何覆盖生成的 API 路径     Maintainer    Features  Response Join point Mybatis Migration Guava Mybatis Plus Auto SQL Builder \u0026 Controller automatic injection Task Scheduling (WIP) Export Simple Excel (WIP)  Quick Start Brahma Cli Spring cli 需要通过 Brahma Cli 进行交互渲染，所以需要先进行安装\n1 2  npm --registry https://nexus.wuchuangroup.com/repository/npm-group/ \\ install -g @fatewa/brahma-cli   安装完成后，使用 create 指令进行项目创建\n1  brahma create app   选择模版 选择模版版本  通常情况下，选择最新的版本即可\n 输入项目描述 在此处输入的描述会进入到 pom.xml description 标签下\n 接下来仅需根据提示输入组织信息(group)、版本信息(version) 这几项 都会在 pom.xml 中生效\n 特性选择(Features) 特性一览表    名称 作用     Mybatis Migration 添加 Mybatis Migration 功能   Mybatis Plus 添加 Mybatis Plus 依赖   Controller DEMO 添加 Controller 样例代码(Hello World Controller)   Env Config File 是否生成 .env 文件   Dockerfile 是否生成 Dockerfile   Gitlab CI 是否生成 .gitlab-ci.yml, 此功能目前版本未实现    选择数据库类型 后续步骤会根据此步骤选择的不同，生成不同的选项， 核心主要为数据库的一些参数\n至此，项目已经生成完毕。\nProject Kernel 是什么 ? Kernel 封装了 spring-cli 功能项的内核代码， 提供了 Response 代理、动态路由注册等核心功能， 同时如果在项目中你希望修改 response 中的 code 字段， 也可以在 kernel / constants / ResponseCode 中进行调整\nMigration 项目中采用的 Migration 是 Mybatis Migration， 如果你希望看到详细的文档请访问官方文档, 为了能够最小化运行我们的项目，我们也会在下文中着重介绍几个指令\n需要注意的是，我们在项目中提供了快捷访问 mybatis migration 的脚本，你可以根据 当前运行的操作系统进行选择\n db.sh 适用于 Mac OSX/Linux db.bat 适用于 Windows   我们正式开始之前，请确保在数据库信息输入步骤中指定的数据库名称，已经被创建\n 状态 Windows:\n1  ./db.bat status   Linux/Mac:\n1  ./db.sh status   pending 即本地有，数据库内没有，需要进行升级\n创建 Windows:\n1  ./db.bat new \"create m_user\"   Linux/Mac:\n1  ./db.sh new \"create m_user\"   执行成功后，会在 migrate/repository/scripts 生成一个新的文件\n输入内容为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  -- // create m_user -- Migration SQL that makes the change goes here. -- 这里写创建的脚本 create table m_user ( id bigserial not null, name varchar(64), age int ); create unique index table_name_id_uindex on m_user (id); alter table m_user add constraint table_name_pk primary key (id); -- //@UNDO -- SQL to undo the change goes here. -- 这里写回退的脚本 drop table m_user;   升级 Windows:\n1  ./db.bat up \u003ccount\u003e   Linux/Mac:\n1  ./db.sh up \u003ccount\u003e   \u003ccount\u003e 为升级的数量(可不填，默认升级到最新版本的SQL) 回退 Windows:\n1  ./db.bat down \u003ccount\u003e   Linux/Mac:\n1  ./db.sh down \u003ccount\u003e   \u003ccount\u003e 为回退的数量(可不填，默认回退一个版本) MybatisX 代码生成 在 Idea 中安装 MybatisX（Mybtis Plus 官方提供的代码生成器）\n以下为配置项选择案例\n在集成的数据库面板中右键点击表，并选中 MybatisX-Generator\nController Response 写法 内核中默认已经实现了全局的返回结果封装，以下为默认的返回格式\n1 2 3 4 5  interface ProtocolResponse { code: string; msg: string; data: any; }   在编写的时候体验如何呢？下面分四个步骤进行介绍\n默认策略 1 2 3 4 5 6 7 8 9 10  // Response 使用子键策略 // 默认放置在 data 下  @GetMapping public CliQuery query(CliQuery query){ final Integer cycle=query.getCycle(); // 使用 Assert 抛出异常，kernel层会自动处理  Assert.state(cycle % 2 != 0, \"循环周期不应是偶数\"); return query; }   此时返回的结果为\n1 2 3 4 5 6 7 8  { code: 'E0001', msg: 'ok', data: { cycle: null, version: null } }   子键策略 1 2 3 4 5 6 7 8 9 10 11 12  /** * Response 使用子键策略 * 并将数据放置在 child 下 */ @GetMapping(\"/keyed\") @Inclusion(value = InclusionStrategy.WITH_KEY, key = \"child\") public CliQuery queryWithKey(CliQuery query) { final Integer cycle = query.getCycle(); // 使用 Assert 抛出异常，kernel层会自动处理  Assert.state(cycle % 2 != 0, \"循环周期不应是偶数\"); return query; }   此时返回的结果为\n1 2 3 4 5 6 7 8  { code: 'E0001', msg: 'ok', child: { cycle: null, version: null } }   平铺策略 1 2 3 4 5 6 7 8 9 10  /** * Response 使用平铺策略 */ @GetMapping(\"tiled\") @Inclusion(InclusionStrategy.TILED) public CliQuery queryTiled(CliQuery query) { final Integer cycle = query.getCycle(); Assert.state(cycle % 2 != 0, \"循环周期不应是偶数\"); return query; }   此时返回的结果为\n1 2 3 4 5 6  { code: 'E0001', msg: 'ok', cycle: null, version: null }   原始类型 有时我们需要在 Controller 返回不同于全局 Response 的数据结构 此时我们就需要用到内核中支持的自定义消息结构\n1 2 3 4 5 6 7 8 9 10 11  /** * 按原样返回不进行处理 */ @GetMapping(\"original\") @OriginalResponse public CliQuery original(CliQuery query) { final Integer cycle = query.getCycle(); // 使用 Assert 抛出异常，kernel层会自动处理  Assert.state(cycle % 2 != 0, \"循环周期不应是偶数\"); return query; }   此时返回的结果为\n1 2 3 4  { cycle: null, version: null }   参数合法性校验 内核中对于参数校验的实现是基于 jpa-validation-api 的 我们仅介绍最小的用法，如果你想要更加详细地了解底层，那么我非常推荐阅读 这篇文章\n参数校验是基于对 Bean 的注解\n1 2 3 4 5 6 7 8 9 10  @Data public class CliQuery { @NotNull(message = \"查询时需要附带版本号\") private String version; @Max(value = 20, message = \"循环次数不应超过20\") private Integer cycle; }   Controller\n1 2 3 4 5 6 7 8  // 在校验参数前面添加注解 @Valid 相当于打开开关  @GetMapping public CliQuery query(@Valid CliQuery query) { final Integer cycle = query.getCycle(); // 使用 Assert 抛出异常，kernel层会自动处理  Assert.state(cycle % 2 != 0, \"循环周期不应是偶数\"); return query; }   断言 由于内核中封装了 Response 的部分，使得我们可以在逻辑判断出错时抛出异常， 并将异常的 msg 作为 response 的 message， 在开始介绍断言之前我们先看一段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * 校验订单是否有效 */ public validateOrder (String orderNo) { if (Strings.isNullOrEmpty(orderNo)) { throw new OrderNotFoundException(\"订单为空\"); } Order order = service.lambdaQueryChain() .eq(Order::getNo, orderNo) .one(); if (null == order) { throw new OrderNotFoundException(\"找不到订单\"); } // ...  }   很显然，这将存在很多 if - throw 的代码块，导致我们代码可读性降低， 为了解决此类问题，我们引入了断言(Spring 自带的断言包)， 下面是使用断言优化后的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13  /** * 校验订单是否有效 */ public validateOrder (String orderNo) { Assert.state(Strings.isNullOrEmpty(orderNo), \"订单为空\") Order order = service.lambdaQueryChain() .eq(Order::getNo, orderNo) .one(); Assert.notNull(order, \"找不到订单\") // ... }   接口导出与开放字段检索 接口导出 内核提供了自动注册 restful api 的功能，使得我们可以较为轻松地 实现 L2 级别的 restful api\n1 2 3 4 5 6 7  /** * 产品 Service * @author 4everlynn */ @Export(path = \"products\", create = true) public interface ProductService extends IService\u003cProduct\u003e {s }   核心在于，在 service 层的接口上添加注解 @Export, 此注解有多个参数， 其释义如下\n   参数 类型 备注 Default     path String 生成接口的基础路径 -   create Boolean 开放 POST 接口(创建) false   update Boolean 开放 PATCH 接口(更新) false   delete Boolean 开放 DELETE 接口(删除) false   page Boolean 开放分页查询接口 true   getFromId Boolean 开放单个对象(根据 ID)查询接口 true    注解添加成功后启动项目，日志中会打印注册的路径\n开放字段检索 开放字段检索的关键在于使用 @Public 注解，此注解也有多个参数， 其释义如下, 默认该字段所以的检索方式都是关闭状态(false)\n   参数 类型 备注 Default     eq Boolean 支持 field = [any] 的查询 false   like Boolean 支持模糊查询 false   between Boolean between … and false   lt Boolean 支持 field \u003c [any] 的查询 false   gt Boolean 支持 field \u003e [any] 的查询 false   le Boolean 支持 field \u003c= 的查询 false   ge Boolean 支持 field \u003e= [any] 的查询 false    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** * * @author 4everlynn */ @EqualsAndHashCode(callSuper = true) @TableName(value =\"product\") @Data public class Product extends AncestorDomain implements Serializable { /** * 产品名称 */ @NotNull(message = \"产品名称不能为空\") @Public(like = true) private String name; }   FAQ 如何使主键在请求结果中进行展示 答: 在 kernel 包中找到 AncestorDomain，去去除 id 字段上方的 @JsonIgnore注解\n生成的 API 格式与请求规范？ 答: 分页请求: /{BASE_PATH} GET\n创建请求: /{BASE_PATH} POST 更新请求: /{BASE_PATH} PATCH（body中需要传递 id）\n删除请求: /{BASE_PATH}/{id} DELETE\n单个查询: /{BASE_PATH}/{id} GET\n如何覆盖生成的 API 路径 答: 定义的路径与自动生成设定的路径一模一样即可\nMaintainer  Edward Jobs   ","description":"","tags":["Spring cli"],"title":"Fatewa | 4everlynn","uri":"/fatewa/posts/work/spring-cli/"},{"categories":["work"],"content":" 导读目录\n   账号体系\n  项目管理\n Issues 里程碑    通知与消息\n 邮件通知 站内通知    权限体系\n 仓库隔离 用户权限类型  Guest Reporter Developer Maintainer Owner      文档管理\n Wiki Markdown UML图 流程图引擎(flow、mermaid)    Devops\n Docker 私有仓库 CI / CD Gitlab Runner    基于Git的分支开发模型 (仅介绍两种)\n Production / Develop Feature / Release    进阶阅读\n Gitlab Hooks Gitlab GraphQL GitLab Pages 从 SVN 迁移 Git 的基本使用    账号体系 graph LR; gitlab(Gitlab) -- group(User Group) up((Account.Core)) -- account(username) up -- avatar up -- nickName up -- pub[public email] up -- com[commit email] up -- password group -- root[Root] -- up group -- admin[Administrator] -- up group -- user[User] -- up   Root \u003e Administrator \u003e User\n具体请查看权限部分\n Example. 实例化的账号体系 graph LR; gitlab(Gitlab) -- group(合成项目组) group -- admin[User - Maintainer - 组长] group -- backend[User - 后端] group -- js[User - 前端] group -- test[User - 测试] group -- ui[User - UI]  项目管理 1 2 3  在 Gitlab 中项目管理主要依托于 Issue, 事实上，大多数基于 Git 研发的项目管理平台皆是如此 所以在这个部分里，我们也是着重介绍 Issue   我们经常在 GitHub 上看到 Issues 往往是网友对于框架提出的一些建议或者 BUG 修正 同样的在Gitlab上，他们的功能是一致的，下面就具体介绍一下。\nIssues Issues 是在 GitLab 中就想法和计划工作进行协作的基本媒介。\n概述 GitLab Issue 跟踪器是一种用于协作开发想法、解决问题和规划工作的高级工具。 Issue 可以允许在提案实施之前和实施期间在以下各方之间共享和讨论提案：\n 你和你的团队。 外部合作者。  它们还可用于各种其他目的，根据您的需求和工作流程进行定制。 Issue 始终与特定项目相关联，但如果您在一个组中有多个项目，您还可以在组级别集中查看所有 Issue。 常见用例包括：\n 讨论新想法的实施 跟踪任务和工作状态 接受功能建议、问题、支持请求或错误报告 详细说明新的代码实现  Issue 的组成 Issue 包含各种内容和元数据，从而在如何使用它们方面具有很大的灵活性。\n每个 Issue 都可以包含以下属性，但并非所有项目都必须设置。\n   名称 备注     Content 内容   Title 标题   Description and tasks 描述与任务   Comments and other activity 评论与其他行为   People 参与的人员   Author 作者   Assignee(s) 执行者(被指派者)   State (open or closed) 状态(打开或者关闭)   Confidentiality 机密性   Milestone 属于某个里程碑   Due date 截止日期   Weight 权重   Labels 标签(如Bug、Feature等)   Votes 投票   Reaction emoji emoji 表情包   Linked issues 链接到其他的issue   Unique issue number and URL 唯一的编号和URL     此外, Issue 完整支持了 Markdown 语法, 在Issue的描述和评论中可自由使用富文本或者 Markdown\n 里程碑 1 2 3 4  GitLab 中的里程碑是一种跟踪问题和合并请求的方法， 这些请求是为了在特定时间段内实现更广泛的目标而创建的。 里程碑允许您组织问题并将请求合并到一个有凝聚力的组中， 并具有可选的开始日期和可选的截止日期。    里程碑的本质是 Issues 的集合\n 里程碑可以用作发布, 设置里程碑到期日期以表示您的版本的发布日期，并将里程碑开始日期留空。\n将里程碑标题设置为您发布的版本，例如Version 9.4.\n通过从问题的右侧边栏中关联所需的里程碑，将问题添加到您的版本中。\n项目里程碑和小组里程碑 项目里程碑只能分配给该项目中的问题或合并请求。\n在项目中的 Issues \u003e Milestone 以查看项目里程碑列表。\n可以将组里程碑分配给该组中任何项目的任何问题或合并请求。\n在组中的 Issue \u003e Milestone 以查看组里程碑列表。\n您有权访问的所有里程碑也可以在仪表板里程碑列表中查看。\n单击顶部导航栏上的里程碑以查看您有权访问的项目里程碑和组里程碑。\n项目级别里程碑 组级别里程碑 通知与消息 在 Gitlab 中大致可以分为两种通知方式\n 邮件通知 站内通知  邮件通知 平台中可以配置邮箱发件账户，并可通过此账户发送邮件给所有的用户, 此处列举几处由系统触发的邮件通知主题\n 代码发生合并 Issue 被评论 被指派到某个 Issue 相关的 Issue 发生操作(标签变更、状态变更等) CI 运行失败 在 Issue 中被提到  站内通知 站内通知在 (/dashboard/todos)  中可以看到, 囊括了所有邮件通知的内容, 同时，在 Service Worker 启用的情况下，Gitlab 会通过浏览器发出 Native 通知。\n权限体系 Gitlab 的权限是建立在组与仓库之上的 关系为 组 \u003e 仓库 如果用户在一个组内被授权, 则在该组下所有的仓库都可以进行访问, 关系图如下所示(由高到低)\ngraph LR; power -- Owner power(权限模型) -- Maintainer power -- Developer power -- Reporter group(组) -.- sub_group(子组) -- repo(仓库) group -.- power sub_group -- power repo -- power  ","description":"","tags":["Git","Gitlab","Work"],"title":"Fatewa | 4everlynn","uri":"/fatewa/posts/work/gitlab/"},{"categories":null,"content":"The director of fatewa  4everlynn is alias for Edward Jobs, Since 2012, I have been involved in programming, from RGSS to Java, JavaScript, PHP and Golang  Led the fatewa team and participated in many projects, including but not limited to  Unilever’s H5 Page Sina’s teachers' grand ceremony Page Construction of official websites of several companies Open-Source Software  ","description":"","tags":null,"title":"Fatewa | 4everlynn","uri":"/fatewa/about/"},{"categories":["web"],"content":"  ","description":"","tags":["BIM","AR"],"title":"Fatewa | 4everlynn","uri":"/fatewa/posts/tech/bim-summary/"},{"categories":["web"],"content":" 在过去的一段时间里，我在项目中参与了一部分 WebGL 的功能实现，主要使用到的技术为 Cesium、ThreeJS， 闲暇之余，就打算记录一下这两个框架的使用，以及与 Vue 封装结合的过程。\n 代码仓库地址, 喜欢记得给个Star呀~\nWhy Three.js 随着 WebGL 逐渐普及，顺应而生的框架也越来越多，在这其中TheeJS在一定程度上来说是知名度、完成度最高的框架，\n也正是其优点之多使得我们在做技术选型的时候，坚定地选择了它，话虽如此，使用过程中，还是遇到了不少棘手的问题，\n在此我便记录、复盘一下整个封装、使用的过程，以便自己将来进行查阅，也为后来者提供一些案例。\nVersion \u0026 Tech  Vue ^2.6.11 three ^0.128.0 Typescript ~4.1.5 rxjs ^6.6.7 vue-styled-components ^1.6.0  Project Struct . ├── App.vue ├── components │ └── base │ ├── fatewa-gl │ │ └── index.tsx # 入口组件 │ └── types │ └── index.ts # 接口、类型定义 ├── libs │ ├── lib-plugins # 各种默认实现的插件 │ └── lib-utils.ts # 工具算法 ├── main.ts ├── router │ └── index.ts ├── shims-tsx.d.ts ├── shims-vue.d.ts ├── textures # 三维纹理 └── views Types 经过设计，框架整体采用插件化编程方式, 将功能解耦，增强代码的可读性的同时也带来了更强的维护性。\n其中 pass 函数从 lib-utils 引入\n仅仅只是一个工具方法，用于排除 eslint 的错误\npass 函数 1 2 3 4 5 6 7 8  /** * 局部规避 eslint 声明未引用的变量规则 * @param args */ // eslint-disable-next-line function pass (args: any) { // passed for eslint }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93  import { Camera, Scene, Renderer } from 'three' import { pass } from '@/libs/lib-utils' /** * 插件安装参数 */ interface PluginInstallOptions { /** * 场景 */ scene: Scene, /** * 摄像头 */ camera: Camera, /** * 渲染器 */ renderer: Renderer } /** * 插件的钩子函数 */ interface PluginHooks { beforeInstall (options: PluginInstallOptions): void afterInstall (options: PluginInstallOptions): void /** * 渲染函数，将在整个主循环中进行渲染 * 需要注意的是，逻辑应尽可能地简单，否则会影响到整体渲染的帧数 * @param options */ render (options: PluginInstallOptions): void } /** * 插件接口 */ interface Plugin extends PluginHooks { /** * 所有的插件需要实现安装方法 * @param options */ install (options: PluginInstallOptions): void } /** * 插件适配器，对于不关心钩子函数的插件 * 直接继承抽象类即可 */ abstract class GLPlugin implements Plugin { /** * 钩子函数的默认实现 * @param options */ afterInstall (options: PluginInstallOptions): void { pass(options) } /** * 钩子函数的默认实现 * @param options */ beforeInstall (options: PluginInstallOptions): void { pass(options) } abstract install(options: PluginInstallOptions): void /** * 钩子函数的默认实现 * @param options */ render (options: PluginInstallOptions): void { pass(options) } } /** * 实体类，暂未实现参数 */ interface Entity { none: any } /** * 组件的 Prop 定义 */ interface GL { entities: Entity [], plugins: Plugin [] } export { GL, Entity, Plugin, PluginInstallOptions, GLPlugin }    对于这个结构下的具体实现，将在后续的文章中介绍\n ","description":"","tags":["three.js","vue"],"title":"Fatewa | 4everlynn","uri":"/fatewa/posts/tech/threejs-chapter-1/"},{"categories":["docker"],"content":" 网站 对于每个人都不陌生，我们每天都在与各种不同的网站进行互动，随着信息化不断发展，很多公司与个人都拥有了自己的网站，很多时候做网站的念头都止步于技术限制，那么今天，我就介绍一个让大家可以很快搭建起自己网站的方法，如果这正是您所需的就继续看下去吧！\n WordPress 正如你所见,今天要介绍的就是大名鼎鼎的 WordPress，使用 WordPress ，您仅需要一点点常用的计算机知识即可，如果您对它还不认识，那么以下是 维基百科 对于 WordPress 的一段描述:\n WordPress是一个以PHP和MySQL为平台的自由开源的博客软件和内容管理系统。WordPress具有插件架构和模板系统。 截至2018年4月，排名前1000万的网站中超过30.6%使用WordPress。 WordPress是最受欢迎的网站内容管理系统。 全球有大约30%的网站(7亿5000个)都是使用WordPress架设网站的。 WordPress是目前因特网上最流行的博客系统。 WordPress在最著名的网络发布阶段中脱颖而出。 如今，它被使用在超过7000万个站点上。\n 或许你对于其中的一些专业术语并不了解，没关系！只要知道这是一个很可靠的系统即可。\n如果你想了解更多关于 WordPress 的知识，可以访问 Wordpress 中文官网\n怎么做 ？ 虽然 Wordpress 多以安装简便著称，但作为没有任何相关知识的群体，想要成功安装仍然具有一定难度，按照传统的方式进行安装，搭建PHP的运行环境就是基础，这一步可能就会劝退很大一部分人，那么今天我要介绍的就是使用 Docker 进行安装的方式，通过这种方式，只需要有一台 Linux 的主机即可(需要支持Docker运行)\n关于 Docker 在这篇文章中，不对 Docker 进行过多的介绍，后续的篇章中我会逐步地介绍这个服务容器化时代超级🔥的开源工具，那么至少在这篇文章中，只需要能够安装并简单使用即可\n安装 Docker 在 CentOS 7 安装docker要求系统为64位、系统内核版本为 3.10 以上，可以使用以下命令查看当前机器的版本\n1  uname -r   运行结果参考\n1 2 3  [root@disware ~]# uname -r 3.10.0-693.5.2.el7.x86_64 [root@disware ~]#    安装完成后可通过以下命令进行验证\n1  docker -v   运行结果参考\n1 2  [root@disware ~]# docker -v Docker version 18.09.5, build e8ff056   安装完成，我们接着安装 docker-compose，由于这个在国内安装比较慢，我们可以通过这里提供的加速服务进行安装\n以下是安装 docker-compose 的命令\n1 2  curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` \u003e /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose   安装完成后，同样地，我们可以通过以下命令进行验证\n1  docker-compose -v   运行结果参考\n1 2  [root@disware ~]# docker-compose -v docker-compose version 1.25.4, build 8d51620a   创建服务文件夹 在此处我以 /opt/wordpress 这个文件夹为例\n1  mkdir /opt/wordpress \u0026\u0026 cd /opt/wordpress   编写 .env 文件 这个文件的主要作用是配置一些环境变量，可以简单地理解成类似于某个软件的配置项, 在当前目录下，我们执行\n1  vi .env   接着将以下内容输入到其中\n1 2 3 4 5 6 7 8  # 数据库名称 DB_NAME=my_website # 数据库 用户名 DB_USER=root # 数据库 密码 DB_PASSWORD=root123 # 数据库 HOST名称 HOST_MYSQL=mysql   有了这个文件，我们就可以紧接着进行编写 docker-compose.yml (服务结构的描述文件)\n1  vi docker-compose.yml   输入内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  version:'3'services:wordpress:image:wordpresshostname:wordpressports:- \"9812:80\"environment:DB_HOST:${HOST_MYSQL}DB_NAME:${DB_NAME}DB_USER:${DB_USER}DB_PASSWORD:${DB_PASSWORD}volumes:- ./data/wordpress/root:/var/www/html- ./logs/php/:/var/log/php/:rwdepends_on:- mysqlmysql:image:mysql:5.7hostname:${HOST_MYSQL}volumes:- ./data/mysql:/var/lib/mysql- ./my.cnf:/etc/my.cnfrestart:alwaysenvironment:MYSQL_ROOT_PASSWORD:${DB_PASSWORD}  然后，由于我们的网站中会有一些中文字符，所以需要对数据库的字符集进行一个配置, 在当前目录下执行\n1  vi my.cnf   输入内容如下\n[mysqld] user=mysql default-storage-engine=INNODB character-set-server=utf8 [client] default-character-set=utf8 [mysql] default-character-set=utf8 启动服务 如果你顺利了进行以上的全部步骤，恭喜！我们可以启动自己的网站了！\n在当前目录下，输入以下命令，即可以后台的形式启动应用\n1  docker-compose up -d   如果在终端中，你看到了以下输出，那么应用正式启动了\n1 2 3 4  [root@disware wordpress]# docker-compose up -d Creating network \"wordpress_default\" with the default driver Creating wordpress_mysql_1 ... done Creating wordpress_wordpress_1 ... done   在正式安装之前，我们还需要创建一个空的数据库\n1 2 3 4 5 6  docker exec -ti wordpress_mysql_1 mysql -u root -proot123 create database `my_website`; exit    在浏览器中输入 http://localhost(或者 Linux IP):9812 即可看到安装界面\n 选择完语言后，你会看到这样一个表单, 按照以下内容填写即可\n   名称 内容     数据库名 my_website   用户名 root   密码 root123   数据库主机 mysql   表前缀 wp_    到此， Wordpress 就安装完成了，后续填写用户名、密码，登陆即可\n","description":"","tags":["docker","wordpress","docker-compose"],"title":"Fatewa | 4everlynn","uri":"/fatewa/posts/docker/wordpress/"},{"categories":["docker"],"content":"前言 技术圈的发展一直以来都是瞬息万变，从去年开始 5G 技术逐渐落地商用，人工智能也慢慢地成熟，就发展而言这几年的速度可以说是达到了一个非常恐怖的地步，在运维领域，技术也是日新月异，而我们今天要介绍的 docker 就是这些年在生产环境中已经广泛被应用的一门技术。\n以下是百度百科中对于 docker 的一段介绍\n Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。\n 什么是容器 容器 与 虚拟机 非常接近，却又不是同一个东西，相较于虚拟机沉重的架构，容器可以说是拥有非常苗条的 ‘身材’，它可以在几秒内启动，并能与宿主机直接进行通讯，与虚拟机不同的是，容器所能做到的隔离，通常是进程级别的，在资源上它是与宿主机共享的，严格来说容器并不是真正的虚拟化。作为开发、运维时使用，我们的每一个服务、应用都对应一个容器，作为应用运行时环境，容器内部一般会装载busybox、alpine等非常轻量的操作系统。\n安装 docker (以 CentOS 7 为例) 安装 yum 源 在终端中输入\n1  curl -f sSL https://get.docker.com/ | sh -s -- --mirror AzureChinaCloud   更新 yum 缓存 1  yum makecache fast   安装最新版 docker 1  yum -y install docker-engine   安装完成后，我们可以通过以下命令进行检验\n1  docker -v   docker 支持的命令 （列举常用） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  Commands: build Build an image from a Dockerfile commit Create a new image from a container's changes exec Run a command in a running container images List images logs Fetch the logs of a container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container start Start one or more stopped containers stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container version Show the Docker version information   Hello World 按照惯例，我们以 Hello World,作为技术入门的案例, 我们使用 pull 命令，拉取 docker-hub 官方仓库中的 hello-world 镜像\n1  docker pull hello-world   然后 输入\n1  docker run hello-world   此时终端会输出下面这段英文\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/   至此，我们就完成了 docker 最基础的应用\n配置镜像仓库 在实际使用的过程中，我们通常会使用国内镜像进行加速(docker-hub 拉取大镜像非常慢)，所以在此处我们继续进行镜像配置。\n1  vi /etc/docker/daemon.json   输入以下内容\n1 2 3 4 5 6 7 8  { \"registry-mirrors\": [ \"https://1nj0zren.mirror.aliyuncs.com\", \"https://docker.mirrors.ustc.edu.cn\", \"http://f1361db2.m.daocloud.io\", \"https://registry.docker-cn.com\" ] }   接着，我们重启 docker 服务使配置生效\n1  systemctl restart docker   ","description":"","tags":["docker"],"title":"Fatewa | 4everlynn","uri":"/fatewa/posts/docker/docker/"}]
