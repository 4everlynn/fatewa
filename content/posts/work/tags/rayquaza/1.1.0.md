---
title: "Rayquaza 1.1.0 RELEASE"
date: 2023-05-30T13:00:10+08:00
tags: [ "Spring cli", "Rayquaza" ]
categories: [ "java" ]
draft: false
---

### One To Many API Available

###### WIP 进行中任务

- RESTful Query (
  即单表中已经支持的查询eq、like、lt、gt...)
- Excel 导出 (即单表中已经支持的 @Intermediary
  注解)
- Projector (查询结果自定义映射)

<focus-tag>@Export</focus-tag>
接口所能覆盖的场景仅局限于单表，导致项目中实际使用的频率较低，本次迭代后，新增了 `一对多`
接口的生成。

> 该功能需结合 @Export 进行使用， 是在 export
> 的基础上进行进一步一对多接口生成

#### Start One To Many API

基础 <focus-tag>@Export</focus-tag> 书写方式

```java
@Export(path = "roles", create = true, update = true)
public interface RoleService extends IService<Role> {}
```

增加关联接口后

```java
@Export(path = "roles", create = true, update = true)
@Relation(value = Permission.class,
        single = true, create = true,
        connector = @RelationConnector(RelationRolePermission.class))
public interface RoleService extends IService<Role> {}
```

增加 <focus-tag>@Relation</focus-tag>
注解即可生成对应一对多接口

![log](/fatewa/posts/work/tags/rayquaza/assets/log.png)

> 基础的单表接口在导出的日志中展示为
<span style="color: #12fd00">绿色</span>
> 一对多接口的接口在导出的日志中展示为
<span style="color: #ff00dd">紫色</span>

##### 路径拼接规则

以 `角色`
为例，我们在案例中的角色导出路径为 `/roles`,
关联的一对多类型为 `Permission`, 拼接 `Permission`
部分的路径规则如下

- Permission 有使用 @Export 导出接口时
    - 使用 `PermissionService` 上的 @Export
      接口的 `path` 参数

- Permission 未使用 @Export 导出接口时
    - 使用 `Permission` 类名称(小写)

###### 实例

<focus-tag link>分页接口 GET</focus-tag>
/roles/`{roleId}`/permissions  
<focus-tag link>单个查询接口 GET</focus-tag>
/roles/`{roleId}`/permissions/`{permissionId}`
<focus-tag link>创建接口 POST</focus-tag>
/roles/`{roleId}`/permissions
> 在 request body 中直接使用 Permission 类
> 的字段即可，会自动进行关联表与实体表数据入库

<focus-tag link>删除接口 DELETE</focus-tag>
/roles/`{roleId}`/permissions/`{permissionId}`

> 仅移除目标类型与当前类型的关联关系，不会直接删除目标数据

<focus-tag link>更新接口 PATCH</focus-tag>
/roles/`{roleId}`/permissions

##### Relation 参数详解

| 名称        | 备注              |
|:----------|:----------------|
| value     | 目标的关联表实体类 Class |
| connector | 连接器，一对多产生的中间关联表 |
| single    | 开放单个查询接口        |
| create    | 开放创建接口          |
| update    | 开放更新接口          |
| page      | 开放分页接口          |
| delete    | 开放删除接口          |

##### RelationConnector 参数详解

| 名称        | 备注                |
|:----------|:------------------|
| value     | 中间关联表实体类 Class    |
| connector | 连接器，一对多产生的中间关联表   |
| key       | 关联表中代表当前实体主键的字段名称 |
| targetKey | 目标实体 key          |

#### 进阶使用

#### 一对多模型

<div style="margin: 25px 0;">1、有中间表</div>

<div class="mermaid">
graph LR;
角色表 --> rpr(角色权限关联表) --> 权限表
</div>

<div style="margin: 25px 0">2、无中间表</div>

<div class="mermaid">
graph LR;
角色表 --> 权限表
</div>

> 两种模型在使用上仅是在 <focus-tag link> 连接器 </focus-tag> 部分参数上会有一些区别

第一种模型就是 `One To Many API Available` 中定义的代码

这里着重介绍一下 `第二种模式`

```java
@Export(path = "roles", create = true, update = true)
@Relation(value = Permission.class,
        single = true, create = true,
        connector = @RelationConnector(Permission.class))
public interface RoleService extends IService<Role> {}
```

在这种模式下，连接器与目标类型是同一个类型(
通常是需要重新配置 `key`, `targetKey`)

> 需要注意的是，在这种模式下，由于不存在中间表，删除接口会直接移除对应实体类


### Data Scope (refactor)

主体，实现了Subject<String>接口，该接口定义了一个名为scope()的方法，该方法返回一个泛型，在此处为 String，表示该主体的范围。在这种情况下，scope()方法返回code属性的值（在该系统中code代表主键）。

```java
/**
 * 客户端信息表
 * @TableName client_details
 */
@TableName(value ="client_details")
@Data
public class ClientDetails implements Serializable, Subject<String> {
    /**
     * 主键
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;

    /**
     * 平台名称（中文）
     */
    @TableField(value = "name")
    private String name;

    /**
     * 同appid
     */
    @TableField(value = "code")
    private String code;

    @Override
    public String scope() {
        return this.code;
    }
}
```


拦截器，该类提供了一种在SQL级别上实现数据隔离的方法。具体来说，它拦截了所有与ClientDetails相关的SQL查询，并将它们限制为当前用户所拥有的客户端。

以下是对该代码的详细解释：

@Component注解将该类标记为Spring组件，以便它可以被自动扫描和注入到其他组件中。

ClientScope类扩展了AbstractSubjectInterceptor类，并指定了两个泛型参数：String和ClientDetails。这些参数分别表示主体的类型和主体的详细信息。

subjects()方法返回当前用户拥有的ClientDetails列表。具体来说，需要实现获取当前用户持有的主体，获取ClientDetails对象，并将它们添加到一个列表中返回。

configure()方法用于配置作用域。在这个方法中，我们使用ScopeConfiguration对象来定义一个作用域，该作用域限制了Role类的查询结果，使其仅限于当前用户所属的客户端。具体来说，我们使用ActionScope类来定义作用域，并指定了Role类和client_code字段作为作用域的限制条件。

```java
@Component
public class ClientScope extends AbstractSubjectInterceptor<String, ClientDetails> {


    /**
     * 该函数为特殊函数，数据拦截在这个方法域内不会生效，可调用任意函数
     * 在 {@link AbstractSubjectInterceptor} 时需要特别小心，未在指定的方法域内进行 service、mapper
     * 调用时，很容易造成循环拦截
     *
     * @return 获取主体
     */
    @Override
    public List<ClientDetails> subjects() {
        return new ArrayList<>();
    }
    
    /**
     * 复写 sql 拼接，自定义实现 sql 拼接方式，
     * 该函数为进阶使用，需要有一定的文本与SQL处理能力
     *
     * @param session         作用域会话
     * @param subjects        当前持有的主体
     * @param mappedStatement 用于调整 SQL
     * @return SQL
     */
    @Override
    protected String getSql(ActionScopeSession session,
                            List<? extends Subject<String>> subjects, MappedStatement mappedStatement) {
        return super.getSql(session, subjects, mappedStatement);
    }
    
    /**
     * 该函数也为白单位方法域，这个域内不会进行 sql 拦截，
     * 可以使用任意 service、mapper
     * 某些情况下需要跳过数据拦截
     */
    @Override
    protected boolean skip() {
        // 管理员跳过数据拦截
        if (isAmin) {
            return true;
        }
        return super.skip();
    }


    /**
     * 配置作用域
     *
     * @param configuration 配置
     */
    @Override
    protected void configure(ScopeConfiguration configuration) {
        configuration.scope(new ActionScope().clazz(Role.class).field("client_code"));
    }

}
```
