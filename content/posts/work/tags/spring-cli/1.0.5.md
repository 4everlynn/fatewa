---
title: "Spring Cli 1.0.5 RELEASE Features"
date: 2021-11-22T13:00:10+08:00
tags: ["Spring cli"]
categories: ["java"]
draft: false
---

<div style="text-align: center;display: flex;flex-direction: column;justify-content:center;align-items:center;margin-bottom: 100px">
     <h1 style="font-weight: 300;text-shadow: 0 0 1px black;">Fatewa <span style="color: #faca30">Spring Cli Release log</span></h1>
     <h3 style="font-weight: 400;font-size: 18px;">Easy to build <b>Stronger</b><span style="margin-left: 8px;border: 1px solid black;padding: 2px 10px;background: #00b583;color: white;font-weight: 300;border-radius: 6px">restful API</span></h3>
     <span style="color: gray;font-size: 13px">
<focus-tag link>
Now at version 1.0.5
</focus-tag>
</span>
</div>


### Features

- [Protocol Exception](#Protocol-Exception)
- [Genius Hooks](#Genius-Hooks)
- [Data Scopes 🔥](#Data-Scopes)

#### Protocol Exception

我们已经知道在 Spring Cli 的项目中，通过 `Assert` 可以返回预期的异常 Response，
但它的局限之处在于，无法调整 `Http Status Code`, 于是为了解决此类问题，在最新(v1.0.5)
版本中，设计了 `ProtocolException`, 一起来看看吧。

```java
// 模拟一个检查订单的方法
public void checkOrder () {

    // 用户未授权
    if (!isAuth()) {
        // 返回时的 Http Status 为 401
        throw new ProtocolException(
            ResponseCode.NO_LOGIN_ERROR, "用户未登录"
        );
    }
    
    // ... 业务代码
}
```

ResponseCode 为枚举类型，可在
<focus-tag link>
&lt;groups&gt;.kernel.constants.ResponseCode
</focus-tag>
中进行自定义扩展
默认情况下，其结构为

```java
public enum ResponseCode {

    /**
     * 参数说明
     */
    SUCCESS("E0001", "请求成功", HttpStatus.OK),
    ERROR_SERVICE("E1001", "平台服务异常",
        HttpStatus.INTERNAL_SERVER_ERROR),
        
    ERROR_DB("E1002", "服务器数据库异常", 
        HttpStatus.INTERNAL_SERVER_ERROR),
        
    UNIQUE_KEY("E1003", "唯一值重复录入",
        HttpStatus.INTERNAL_SERVER_ERROR),
        
    TRANSFORM_ERROR("E1004", "类型转换错误", 
        HttpStatus.INTERNAL_SERVER_ERROR),
        
    ERROR_QUERY("E2001", "请求参数异常，缺少必填项", 
        HttpStatus.BAD_REQUEST),
        
    ERROR_QUERY_FORMAT("E2002", "请求参数异常，参数格式不合法",
         HttpStatus.BAD_REQUEST),
         
    NO_LOGIN_ERROR("E4001", "请先登录", HttpStatus.UNAUTHORIZED);

    /**
     * 值
     */
    public String value;
    
    /**
     * 对应信息
     */
    public String msg;

    /**
     * 对应 Http Status
     */
    public HttpStatus status;
}
```

#### Genius Hooks

在以往的 Spring cli 版本中，我们已经能够借助于 <focus-tag link> @Export </focus-tag>
注解所提供的能力进行 Level 2 的 Restful API 自动生成，可是在实际的业务研发中，我们发现，这些
生成的接口往往不能完全胜任业务需求或者说无法跟随业务而进行扩展，因此我们的用户还是选择自行创建
并重新实现接口，而这也就意味着，丢失了 Spring cli 中所自带的 validation scope (即区分 Create、Update 的参数校验)，
在这样的前提背景下，Genius Hooks 就自然而然的出现了。

我们将 `Genius Hooks` 贯穿进了 GeniusProxyWrapper, 它的流程如下图

<div style="margin-bottom: 45px;text-align: center" class="mermaid">
graph TB;
    r(Request&lt;T&gt;)
    c(Create Entity)
    u(Update Entity)
    d(Delete Entity)
    e(End)
    r --post--> hooks.beforeCreate --> c --> hooks.created --> e
    r --patch--> hooks.beforeUpdate --> u --> hooks.updated --> e
    r --delete--> hooks.beforeDelete --> d --> hooks.deleted --> e

</div>

使用案例

```java
@Configuration
public class KernelConfig {

    // 配置为 StoreInfo 的 Hook
    @Bean
    GeniusHooks<StoreInfo> hooks () {
        return new GeniusHooks<StoreInfo>() {
        
        // 数据创建完成的钩子
        @Override
        public void created(AncestorDomain domain, boolean s) {
                // 返回的是父类型，需要向下转型
                final StoreInfo storeInfo = (StoreInfo) domain;
                System.out.println(storeInfo);
            }
        };
    }
    
}
```

> 在钩子内抛出异常可以中断接口进行
> 也可以结合上文中的 ProtocolException 进行 HttpStatus 控制


#### Data Scopes

作为现代化开箱即用的应用框架，数据隔离是绕不开的话题，在此前 Spring Cli 的结构中，
由于接口的高度自动化，导致用户很难在不去调整核心源码的前提下去控制数据的隔离，但是不必担心，
在这个版本中，此机制已被实现。

现有的核心代码中，已经集成了此功能，但默认是未开启的状态，需要向 Spring 容器中注册一个
<focus-tag link>ScopedContext</focus-tag> 类才可以开启:

```java
@Configuration
public class KernelConfig {

    // 配置权限上下文
    @Bean
    public ScopedContext context(JdbcTemplate template) {
        return new RequestScopeContext()
                // Session 有效性校验器
                .calibrator((authorization, request) -> false)
                // JdbcTemplate 使用默认的即可
                .jdbcTemplate(template)
                // 权限字段处理器
                .configure(chain -> chain.scope(new ScopedStore()));
    }
    
}
```

权限字段处理器
```java
    public class ScopedStore
            extends BaseScopeHandler<List<StoreInfo>> {
    
        // 获取时使用的 key
        @Override
        public String key() {
            return "stores";
        }

        // 根据需要构建SQL，从 操作符 开始写即可，
        // 字段名称会进行自动注入
        @Override
        public SqlBuilder<List<StoreInfo>> builder() {
            return args -> Joiner.on("")
            .join(" in ", "(",
                    Strings.join(args.stream()
                    .map(StoreInfo::getId)
                    .collect(Collectors.toList()), ','),
                    ")");
        }

        // 使用 JdbcTemplate 进行数据库访问
        @Override
        public List<StoreInfo> scopes() {
            final JdbcTemplate template = template();
            return template.query("select * from biz.store_info", 
                BeanPropertyRowMapper.newInstance(StoreInfo.class));
        }
    }
```

```java
@EqualsAndHashCode(callSuper = true)
@TableName(value = "store_info", schema = "biz")
@Data
public class StoreInfo extends AncestorDomain {
    private Long pid;

    /**
     * 在对应的实体类增加注解
     */
    @Scoped(value = KernelConfig.ScopedStore.class, key = "id")
    @TableField(exist = false)
    private String storeId;
    
}
```
